An example to show details of c++ virtual function table and rtti information in memory layout.

c++在类的实例中第一个存储位置存放着虚函数表指针（如果是单继承关系类，类实例第一个8 byte位置存放一个虚函数表指针；如果是多重继承关系n个父类，类实例存放n个8 byte的虚函数表指针），该虚函数表指针指向虚函数表（虚函数表是虚函数数组，按照派生关系和声明顺序在编译时按顺序排列好），虚函数表数组索引的-1位置存放着类的RTTI信息，即一个type_info* 类型的指针，该指针中的name()存放着由编译器name mangling后的类的名字，如果多重继承场景，n个虚函数表的内容虽然完全不同，但每个虚函数表的-1索引处存放的type_info* 指针都指向同一个type_info对象，这样可以能保证程序在运行时方便查找对象之间的继承关系；
类实例的虚函数表在类继承中如果有子类重写父类虚函数的操作，在编译时子类的虚函数表中相应的虚函数的地址会被相应的替换掉；
类的实例中仅存储类对象的成员变量和虚函数表指针，成员变量在类继承中有数据对齐的隐含操作，比如，父类中有一个int数据成员，子类中有两个int数据成员时，sizeof(父类实例)=16(8+4+4)，编译器会填充一个数据成员来对齐，sizeof(子类实例)=24(8+4+4+4+4);
类的非虚函数地址既不存放在类实例的存储空间，也不会存放在类实例的虚函数表中，调用时直接跳转到非虚函数地址处，非虚函数有一个隐藏的this* 指针形参来建立该非虚函数和类实例之间的关系。
